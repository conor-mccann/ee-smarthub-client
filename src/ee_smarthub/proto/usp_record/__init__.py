# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: usp-record-1-4.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "DisconnectRecord",
    "MqttConnectRecord",
    "MqttConnectRecordMqttVersion",
    "NoSessionContextRecord",
    "Record",
    "RecordPayloadSecurity",
    "SessionContextRecord",
    "SessionContextRecordPayloadSarState",
    "StompConnectRecord",
    "StompConnectRecordStompVersion",
    "UdsConnectRecord",
    "WebSocketConnectRecord",
)

from dataclasses import dataclass

import betterproto2

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class MqttConnectRecordMqttVersion(betterproto2.Enum):
    V3_1_1 = 0
    """
    Represents MQTT v3.1.1, a.k.a. v4 in the MQTT Spec
    """

    V5 = 1


class RecordPayloadSecurity(betterproto2.Enum):
    PLAINTEXT = 0

    TLS12 = 1


class SessionContextRecordPayloadSarState(betterproto2.Enum):
    NONE = 0
    """
    No segmentation
    """

    BEGIN = 1
    """
    Begin segmentation
    """

    INPROCESS = 2
    """
    Segmentation in process
    """

    COMPLETE = 3
    """
    Segmentation is complete
    """


class StompConnectRecordStompVersion(betterproto2.Enum):
    V1_2 = 0


@dataclass(eq=False, repr=False)
class DisconnectRecord(betterproto2.Message):
    reason: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    reason_code: "int" = betterproto2.field(2, betterproto2.TYPE_FIXED32)


default_message_pool.register_message(
    "usp_record", "DisconnectRecord", DisconnectRecord
)


@dataclass(eq=False, repr=False)
class MqttConnectRecord(betterproto2.Message):
    version: "MqttConnectRecordMqttVersion" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MqttConnectRecordMqttVersion(0),
    )

    subscribed_topic: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "usp_record", "MQTTConnectRecord", MqttConnectRecord
)


@dataclass(eq=False, repr=False)
class NoSessionContextRecord(betterproto2.Message):
    payload: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "usp_record", "NoSessionContextRecord", NoSessionContextRecord
)


@dataclass(eq=False, repr=False)
class Record(betterproto2.Message):
    """


    Oneofs:
        - record_type:
    """

    version: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    to_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    from_id: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    payload_security: "RecordPayloadSecurity" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: RecordPayloadSecurity(0)
    )

    mac_signature: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    MAC or Signature
    """

    sender_cert: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)

    no_session_context: "NoSessionContextRecord | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )

    session_context: "SessionContextRecord | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )

    websocket_connect: "WebSocketConnectRecord | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )

    mqtt_connect: "MqttConnectRecord | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )

    stomp_connect: "StompConnectRecord | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )

    disconnect: "DisconnectRecord | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )

    uds_connect: "UdsConnectRecord | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="record_type"
    )


default_message_pool.register_message("usp_record", "Record", Record)


@dataclass(eq=False, repr=False)
class SessionContextRecord(betterproto2.Message):
    session_id: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)

    sequence_id: "int" = betterproto2.field(2, betterproto2.TYPE_UINT64)

    expected_id: "int" = betterproto2.field(3, betterproto2.TYPE_UINT64)

    retransmit_id: "int" = betterproto2.field(4, betterproto2.TYPE_UINT64)

    payload_sar_state: "SessionContextRecordPayloadSarState" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SessionContextRecordPayloadSarState(0),
    )

    payloadrec_sar_state: "SessionContextRecordPayloadSarState" = betterproto2.field(
        6,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SessionContextRecordPayloadSarState(0),
    )

    payload: "list[bytes]" = betterproto2.field(
        7, betterproto2.TYPE_BYTES, repeated=True
    )


default_message_pool.register_message(
    "usp_record", "SessionContextRecord", SessionContextRecord
)


@dataclass(eq=False, repr=False)
class StompConnectRecord(betterproto2.Message):
    version: "StompConnectRecordStompVersion" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: StompConnectRecordStompVersion(0),
    )

    subscribed_destination: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "usp_record", "STOMPConnectRecord", StompConnectRecord
)


@dataclass(eq=False, repr=False)
class UdsConnectRecord(betterproto2.Message):
    """
    An empty message
    """

    pass


default_message_pool.register_message(
    "usp_record", "UDSConnectRecord", UdsConnectRecord
)


@dataclass(eq=False, repr=False)
class WebSocketConnectRecord(betterproto2.Message):
    """
    An empty message
    """

    pass


default_message_pool.register_message(
    "usp_record", "WebSocketConnectRecord", WebSocketConnectRecord
)
